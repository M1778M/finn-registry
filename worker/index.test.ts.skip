import { describe, it, expect, beforeAll } from 'vitest';
import { env, SELF } from 'cloudflare:test';

// Type definitions for API responses
interface HealthResponse {
  status: string;
  timestamp: number;
}

interface StatsResponse {
  packages: number;
  users: number;
  downloads: number;
}

interface PackageListResponse {
  packages: unknown[];
  total: number;
  limit: number;
  offset: number;
}

interface PackageDetailResponse {
  name: string;
  description: string;
  repo_url: string;
  versions: unknown[];
  [key: string]: unknown;
}

interface UserResponse {
  username: string;
  packages: unknown[];
  [key: string]: unknown;
}

interface AuthMeResponse {
  user: unknown | null;
  packages?: unknown[];
}

interface SuccessResponse {
  success: boolean;
}

interface ErrorResponse {
  error: string;
}

interface CliAuthResponse {
  authenticated: boolean;
  user: unknown;
}

// Setup database schema before tests
beforeAll(async () => {
  // Create tables
  await env.finn_db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      username TEXT NOT NULL UNIQUE,
      github_id INTEGER UNIQUE,
      avatar_url TEXT,
      email TEXT,
      api_token TEXT UNIQUE,
      created_at INTEGER DEFAULT (unixepoch())
    );

    CREATE TABLE IF NOT EXISTS sessions (
      id TEXT PRIMARY KEY,
      user_id INTEGER NOT NULL,
      expires_at INTEGER NOT NULL,
      created_at INTEGER DEFAULT (unixepoch()),
      FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS packages (
      name TEXT PRIMARY KEY,
      description TEXT,
      repo_url TEXT NOT NULL,
      homepage TEXT,
      keywords TEXT,
      license TEXT DEFAULT 'MIT',
      owner_id INTEGER,
      downloads INTEGER DEFAULT 0,
      created_at INTEGER DEFAULT (unixepoch()),
      updated_at INTEGER DEFAULT (unixepoch()),
      FOREIGN KEY (owner_id) REFERENCES users(id)
    );

    CREATE TABLE IF NOT EXISTS versions (
      package_name TEXT,
      version TEXT,
      commit_hash TEXT,
      changelog TEXT,
      created_at INTEGER DEFAULT (unixepoch()),
      PRIMARY KEY (package_name, version),
      FOREIGN KEY (package_name) REFERENCES packages(name) ON DELETE CASCADE
    );
  `);

  // Seed test data
  await env.finn_db.exec(`
    INSERT OR IGNORE INTO users (id, username, github_id, api_token) 
    VALUES (1, 'testuser', 12345, 'finn_tok_testtoken123');

    INSERT OR IGNORE INTO packages (name, description, repo_url, owner_id, downloads) 
    VALUES ('test-pkg', 'A test package', 'https://github.com/test/test-pkg.git', 1, 100);

    INSERT OR IGNORE INTO packages (name, description, repo_url, owner_id, downloads) 
    VALUES ('another-pkg', 'Another package', 'https://github.com/test/another.git', 1, 50);

    INSERT OR IGNORE INTO versions (package_name, version, commit_hash) 
    VALUES ('test-pkg', '1.0.0', 'abc123');
  `);
});

describe('Health Check API', () => {
  it('GET /api/health returns ok status', async () => {
    const response = await SELF.fetch('http://localhost/api/health');
    expect(response.status).toBe(200);
    
    const data = await response.json() as HealthResponse;
    expect(data.status).toBe('ok');
    expect(data.timestamp).toBeDefined();
  });
});

describe('Stats API', () => {
  it('GET /api/stats returns registry statistics', async () => {
    const response = await SELF.fetch('http://localhost/api/stats');
    expect(response.status).toBe(200);
    
    const data = await response.json() as StatsResponse;
    expect(typeof data.packages).toBe('number');
    expect(typeof data.users).toBe('number');
    expect(typeof data.downloads).toBe('number');
  });
});

describe('Search API', () => {
  it('GET /api/search returns packages matching query', async () => {
    const response = await SELF.fetch('http://localhost/api/search?q=test');
    expect(response.status).toBe(200);
    
    const data = await response.json() as unknown[];
    expect(Array.isArray(data)).toBe(true);
  });

  it('GET /api/search returns empty array for no matches', async () => {
    const response = await SELF.fetch('http://localhost/api/search?q=nonexistent12345');
    expect(response.status).toBe(200);
    
    const data = await response.json() as unknown[];
    expect(Array.isArray(data)).toBe(true);
    expect(data.length).toBe(0);
  });

  it('GET /api/search with empty query returns results', async () => {
    const response = await SELF.fetch('http://localhost/api/search?q=');
    expect(response.status).toBe(200);
    
    const data = await response.json() as unknown[];
    expect(Array.isArray(data)).toBe(true);
  });
});

describe('Packages API', () => {
  it('GET /api/packages returns paginated list', async () => {
    const response = await SELF.fetch('http://localhost/api/packages');
    expect(response.status).toBe(200);
    
    const data = await response.json() as PackageListResponse;
    expect(data.packages).toBeDefined();
    expect(Array.isArray(data.packages)).toBe(true);
    expect(typeof data.total).toBe('number');
    expect(typeof data.limit).toBe('number');
    expect(typeof data.offset).toBe('number');
  });

  it('GET /api/packages respects limit and offset', async () => {
    const response = await SELF.fetch('http://localhost/api/packages?limit=1&offset=0');
    expect(response.status).toBe(200);
    
    const data = await response.json() as PackageListResponse;
    expect(data.limit).toBe(1);
    expect(data.offset).toBe(0);
    expect(data.packages.length).toBeLessThanOrEqual(1);
  });

  it('GET /api/packages/:name returns package details', async () => {
    const response = await SELF.fetch('http://localhost/api/packages/test-pkg');
    expect(response.status).toBe(200);
    
    const data = await response.json() as PackageDetailResponse;
    expect(data.name).toBe('test-pkg');
    expect(data.description).toBeDefined();
    expect(data.repo_url).toBeDefined();
    expect(data.versions).toBeDefined();
    expect(Array.isArray(data.versions)).toBe(true);
  });

  it('GET /api/packages/:name returns 404 for non-existent package', async () => {
    const response = await SELF.fetch('http://localhost/api/packages/nonexistent-pkg');
    expect(response.status).toBe(404);
    
    const data = await response.json() as ErrorResponse;
    expect(data.error).toBeDefined();
  });

  it('GET /api/packages/:name/versions returns version list', async () => {
    const response = await SELF.fetch('http://localhost/api/packages/test-pkg/versions');
    expect(response.status).toBe(200);
    
    const data = await response.json() as unknown[];
    expect(Array.isArray(data)).toBe(true);
  });
});

describe('User API', () => {
  it('GET /api/users/:username returns user profile', async () => {
    const response = await SELF.fetch('http://localhost/api/users/testuser');
    expect(response.status).toBe(200);
    
    const data = await response.json() as UserResponse;
    expect(data.username).toBe('testuser');
    expect(data.packages).toBeDefined();
    expect(Array.isArray(data.packages)).toBe(true);
  });

  it('GET /api/users/:username returns 404 for non-existent user', async () => {
    const response = await SELF.fetch('http://localhost/api/users/nonexistentuser');
    expect(response.status).toBe(404);
    
    const data = await response.json() as ErrorResponse;
    expect(data.error).toBeDefined();
  });
});

describe('Auth API', () => {
  it('GET /api/auth/me returns null user when not authenticated', async () => {
    const response = await SELF.fetch('http://localhost/api/auth/me');
    expect(response.status).toBe(200);
    
    const data = await response.json() as AuthMeResponse;
    expect(data.user).toBeNull();
  });

  it('POST /api/auth/logout returns success', async () => {
    const response = await SELF.fetch('http://localhost/api/auth/logout', {
      method: 'POST',
    });
    expect(response.status).toBe(200);
    
    const data = await response.json() as SuccessResponse;
    expect(data.success).toBe(true);
  });
});

describe('CLI Auth API', () => {
  it('POST /api/cli/auth validates API token', async () => {
    const response = await SELF.fetch('http://localhost/api/cli/auth', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ api_token: 'finn_tok_testtoken123' }),
    });
    expect(response.status).toBe(200);
    
    const data = await response.json() as CliAuthResponse;
    expect(data.authenticated).toBe(true);
    expect(data.user).toBeDefined();
  });

  it('POST /api/cli/auth rejects invalid token', async () => {
    const response = await SELF.fetch('http://localhost/api/cli/auth', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ api_token: 'invalid_token' }),
    });
    expect(response.status).toBe(401);
    
    const data = await response.json() as ErrorResponse;
    expect(data.error).toBeDefined();
  });

  it('POST /api/cli/auth requires api_token', async () => {
    const response = await SELF.fetch('http://localhost/api/cli/auth', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
    });
    expect(response.status).toBe(400);
    
    const data = await response.json() as ErrorResponse;
    expect(data.error).toBeDefined();
  });
});

describe('Protected Endpoints', () => {
  it('POST /api/packages requires authentication', async () => {
    const response = await SELF.fetch('http://localhost/api/packages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'new-pkg', repo_url: 'https://github.com/test/new.git' }),
    });
    expect(response.status).toBe(401);
  });

  it('POST /api/auth/token/regenerate requires authentication', async () => {
    const response = await SELF.fetch('http://localhost/api/auth/token/regenerate', {
      method: 'POST',
    });
    expect(response.status).toBe(401);
  });

  it('DELETE /api/packages/:name requires authentication', async () => {
    const response = await SELF.fetch('http://localhost/api/packages/test-pkg', {
      method: 'DELETE',
    });
    expect(response.status).toBe(401);
  });
});
